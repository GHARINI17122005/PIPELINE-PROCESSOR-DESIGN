# PIPELINE-PROCESSOR-DESIGN

*COMPANY*: CODTECH IT SOLUTIONS

*NAME*: HARINI G

*INTERN ID*: CT04DR2924

*DOMAIN*: VLSI

*DURATION*: 4 WEEKS

*MENTOR*: NEELA SANTOSH

*DESCRIPTION*:

As part of my internship, I was assigned the task of designing and simulating a 4-stage pipelined processor capable of executing basic instructions such as ADD, SUB, and LOAD, using Verilog HDL and an industry-standard Electronic Design Automation (EDA) tool. This project provided an excellent opportunity to gain practical experience with processor architecture, pipeline operation, hazard handling, and simulation-based verification. The task involved not only coding the processor but also understanding the flow of instructions through multiple stages simultaneously, which required careful design of pipeline registers and control logic to prevent data hazards and ensure proper synchronization. I analysed how instructions could overlap in execution without causing incorrect results, and implemented techniques to maintain the correct sequence of read and write operations across stages. The processor was divided into four fundamental stages—Instruction Fetch (IF), Instruction Decode (ID), Execute (EX), and Write Back (WB)—with each stage functioning in parallel, enabling one instruction to complete per clock cycle once the pipeline became fully loaded. The instruction set supported three essential operations: ADD, SUB, and LOAD, where ADD and SUB performed arithmetic on registers, while LOAD moved data from memory to a register. In the Instruction Fetch stage, the program counter (PC) generated the address for the next instruction, and the instruction memory output was captured synchronously on the rising clock edge. During the Instruction Decode stage, the instruction opcode and register fields were interpreted, and the required source register values were read from the register file. The Execute stage performed the actual arithmetic operations using an ALU, or in the case of LOAD, generated the memory address. Finally, the Write Back stage updated the appropriate register with the computed or loaded value. I implemented each of these stages using Verilog modules and pipeline registers between them to ensure that data and control signals propagated cleanly through the pipeline. After completing the functional design, I created a detailed testbench that initialized the processor, loaded a small instruction sequence into instruction memory, and generated a stable clock to drive the pipeline. The testbench applied reset signals, monitored register values, and observed instruction flow through each pipeline stage. Once the Verilog code and testbench were ready, I moved on to the simulation process using the EDA tool provided during the internship. The EDA tool proved extremely valuable, offering features such as real-time waveform visualization, hierarchy navigation, timing analysis, and signal tracing that helped me understand the processor’s cycle-by-cycle behaviour. I compiled the Verilog files, resolved minor syntax warnings, and launched the simulation. In the waveform viewer, I carefully observed how each instruction moved through the pipeline. During IF, I watched the instruction memory output update as the PC incremented every cycle. In ID, I verified that the opcode, source registers, and destination register were decoded correctly and that the register file produced the correct operand values. In the EX stage, I validated that the ALU performed addition and subtraction accurately and that memory addresses were computed correctly for LOAD instructions. During the Write Back stage, I ensured that the correct register was updated with the ALU or memory value at the appropriate cycle. The waveform timeline clearly showed how multiple instructions overlapped in the pipeline, demonstrating true pipelined execution. The EDA tool allowed me to zoom into specific cycles, monitor hazards, track control signals, and verify that pipeline registers held the correct intermediate values. One of the important aspects I analysed was whether the pipeline experienced any read-after-write hazards, and the waveform confirmed that the basic instruction sequence executed without conflicts. I captured screenshots of the simulation, showing instruction flow through each pipeline stage, ALU outputs, memory access values, and register updates. These visual results were included in my simulation documentation to demonstrate correct processor operation. Overall, designing and verifying this pipelined processor greatly enhanced my understanding of digital architecture, synchronous pipeline flow, and hardware verification. It gave me valuable hands-on experience with Verilog HDL, EDA simulation workflows, and processor-level debugging, all of which strengthened my technical confidence. I am grateful to Codtech for providing me this excellent opportunity to explore processor design and gain meaningful real-world engineering experience.

*OUTPUT*:

![Image](https://github.com/user-attachments/assets/aa12a5fa-4c78-4726-b19a-5cbe40aa6677)
